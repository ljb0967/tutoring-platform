{"ast":null,"code":"var _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nvar jwt = require('jsonwebtoken');\nvar bcrypt = require('bcrypt');\nvar User = require('./models/User');\nvar nodemailer = require('nodemailer');\nvar transporter = nodemailer.createTransport({\n  service: 'gmail',\n  auth: {\n    user: process.env.EMAIL_USER,\n    pass: process.env.EMAIL_PASS\n  }\n});\nexports.register = function () {\n  var _ref = _asyncToGenerator(function* (req, res) {\n    try {\n      console.log(\"Received registration request:\", req.body);\n      var _req$body = req.body,\n        email = _req$body.email,\n        password = _req$body.password,\n        name = _req$body.name,\n        university = _req$body.university,\n        major = _req$body.major;\n      var hashedPassword = yield bcrypt.hash(password, 10);\n      var user = new User({\n        email: email,\n        password: hashedPassword,\n        name: name,\n        university: university,\n        major: major,\n        isVerified: false\n      });\n      var verificationToken = jwt.sign({\n        email: user.email\n      }, process.env.JWT_SECRET, {\n        expiresIn: '1h'\n      });\n      var mailOptions = {\n        from: process.env.EMAIL_USER,\n        to: user.email,\n        subject: 'Email Verification',\n        text: `Please verify your email by clicking on the following link: \n      http://localhost:3000/api/users/verify-email?token=${verificationToken}`\n      };\n      yield transporter.sendMail(mailOptions);\n      yield user.save();\n      res.status(201).json({\n        message: '사용자 등록 성공. 이메일 인증을 완료해주세요.'\n      });\n    } catch (error) {\n      console.error(\"Error during registration:\", error);\n      res.status(500).json({\n        error: '서버 오류'\n      });\n    }\n  });\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexports.verifyEmail = function () {\n  var _ref2 = _asyncToGenerator(function* (req, res) {\n    try {\n      console.log(\"Verify email request received:\", req.query.token);\n      var token = req.query.token;\n      if (!token) {\n        console.log(\"No token provided\");\n        return res.status(400).json({\n          error: '토큰이 제공되지 않았습니다.'\n        });\n      }\n      var decoded = jwt.verify(token, process.env.JWT_SECRET);\n      console.log(\"Decoded token:\", decoded);\n      var user = yield User.findOne({\n        email: decoded.email\n      });\n      if (!user) {\n        console.log(\"Invalid user\");\n        return res.status(400).json({\n          error: '유효하지 않은 사용자입니다.'\n        });\n      }\n      user.isVerified = true;\n      yield user.save();\n      console.log(\"Email verification successful\");\n      res.status(200).json({\n        message: '이메일 인증이 성공적으로 완료되었습니다.'\n      });\n    } catch (error) {\n      console.error(\"Email verification error:\", error);\n      res.status(500).json({\n        error: '서버 오류'\n      });\n    }\n  });\n  return function (_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nexports.login = function () {\n  var _ref3 = _asyncToGenerator(function* (req, res) {\n    try {\n      var _req$body2 = req.body,\n        email = _req$body2.email,\n        password = _req$body2.password;\n      console.log(\"Received login request for:\", email);\n      var user = yield User.findOne({\n        email: email\n      });\n      if (!user) return res.status(400).json({\n        error: '사용자를 찾을 수 없습니다'\n      });\n      var validPassword = yield bcrypt.compare(password, user.password);\n      if (!validPassword) return res.status(400).json({\n        error: '비밀번호가 올바르지 않습니다'\n      });\n      if (!process.env.JWT_SECRET) {\n        throw new Error('JWT_SECRET is not set');\n      }\n      var token = jwt.sign({\n        userId: user._id,\n        university: user.university\n      }, process.env.JWT_SECRET, {\n        expiresIn: '1h'\n      });\n      console.log(\"Login successful, token generated with university\");\n      res.json({\n        token: token\n      });\n    } catch (error) {\n      console.error(\"Server error during login:\", error);\n      res.status(500).json({\n        error: '서버 오류'\n      });\n    }\n  });\n  return function (_x5, _x6) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nexports.authenticateToken = function (req, res, next) {\n  var authHeader = req.headers['authorization'];\n  var token = authHeader && authHeader.split(' ')[1];\n  if (!token) return res.status(401).json({\n    error: '토큰이 제공되지 않았습니다.'\n  });\n  jwt.verify(token, process.env.JWT_SECRET, function (err, user) {\n    if (err) return res.status(403).json({\n      error: '유효하지 않은 토큰입니다.'\n    });\n    req.user = user;\n    console.log('Decoded user from token:', req.user);\n    next();\n  });\n};","map":{"version":3,"names":["jwt","require","bcrypt","User","nodemailer","transporter","createTransport","service","auth","user","process","env","EMAIL_USER","pass","EMAIL_PASS","exports","register","_ref","_asyncToGenerator","req","res","console","log","body","_req$body","email","password","name","university","major","hashedPassword","hash","isVerified","verificationToken","sign","JWT_SECRET","expiresIn","mailOptions","from","to","subject","text","sendMail","save","status","json","message","error","_x","_x2","apply","arguments","verifyEmail","_ref2","query","token","decoded","verify","findOne","_x3","_x4","login","_ref3","_req$body2","validPassword","compare","Error","userId","_id","_x5","_x6","authenticateToken","next","authHeader","headers","split","err"],"sources":["C:/startcoding/tutoring-platform/auth.js"],"sourcesContent":["const jwt = require('jsonwebtoken');\r\nconst bcrypt = require('bcrypt');\r\nconst User = require('./models/User');\r\nconst nodemailer = require('nodemailer');\r\n\r\n// 이메일 전송 설정\r\nconst transporter = nodemailer.createTransport({\r\n  service: 'gmail',\r\n  auth: {\r\n    user: process.env.EMAIL_USER, // 예: your-email@gmail.com\r\n    pass: process.env.EMAIL_PASS, // Gmail 계정의 앱 비밀번호\r\n  },\r\n});\r\n\r\n// exports.register = async (req, res) => {\r\n//   try {\r\n//     const { email, password, name, university, major } = req.body;\r\n//     const hashedPassword = await bcrypt.hash(password, 10);\r\n//     const user = new User({ email, password: hashedPassword, name, university, major });\r\n//     console.log(\"Saving user:\", user); // 로그 추가\r\n//     await user.save();\r\n//     res.status(201).json({ message: '사용자 등록 성공' });\r\n//   } catch (error) {\r\n//     res.status(500).json({ error: '서버 오류' });\r\n//     console.error(\"Error during user registration:\", error); // 로그 추가\r\n//   }\r\n// };\r\n\r\nexports.register = async (req, res) => {\r\n  try {\r\n    \r\n    console.log(\"Received registration request:\", req.body); // 로그 추가\r\n    const { email, password, name, university, major } = req.body;\r\n\r\n    \r\n    // 이메일 도메인 확인 (예: @university.edu만 허용)\r\n    // if (!email.endsWith('@university.edu')) {\r\n    //   return res.status(400).json({ error: '허용되지 않은 이메일 도메인입니다.' });\r\n    // }\r\n\r\n    const hashedPassword = await bcrypt.hash(password, 10);\r\n    const user = new User({ email, password: hashedPassword, name, university, major, isVerified: false });\r\n\r\n    // 이메일 인증 토큰 생성\r\n    const verificationToken = jwt.sign({ email: user.email }, process.env.JWT_SECRET, { expiresIn: '1h' });\r\n\r\n    // 인증 이메일 전송\r\n    const mailOptions = {\r\n      from: process.env.EMAIL_USER,\r\n      to: user.email,\r\n      subject: 'Email Verification',\r\n      text: `Please verify your email by clicking on the following link: \r\n      http://localhost:3000/api/users/verify-email?token=${verificationToken}`,\r\n    };\r\n\r\n    await transporter.sendMail(mailOptions);\r\n\r\n    // 유저 정보를 DB에 임시로 저장\r\n    await user.save();\r\n    res.status(201).json({ message: '사용자 등록 성공. 이메일 인증을 완료해주세요.' });\r\n  } catch (error) {\r\n    console.error(\"Error during registration:\", error);  // 오류 로그 출력\r\n    res.status(500).json({ error: '서버 오류' });\r\n  }\r\n};\r\n\r\n// 이메일 인증 핸들러 추가\r\n// exports.verifyEmail = async (req, res) => {\r\n//   try {\r\n//     const token = req.query.token;\r\n//     const decoded = jwt.verify(token, process.env.JWT_SECRET);\r\n\r\n//     // 이메일을 찾아서 인증 상태를 true로 업데이트\r\n//     const user = await User.findOneAndUpdate(\r\n//       { email: decoded.email },\r\n//       { isVerified: true },\r\n//       { new: true }\r\n//     );\r\n\r\n//     if (!user) {\r\n//       return res.status(400).json({ error: '사용자를 찾을 수 없습니다.' });\r\n//     }\r\n\r\n//     res.status(200).json({ message: '이메일 인증이 완료되었습니다.' });\r\n//   } catch (error) {\r\n//     res.status(500).json({ error: '서버 오류' });\r\n//   }\r\n// };\r\n\r\n// exports.verifyEmail = async (req, res) => {\r\n//   try {\r\n//       console.log(\"Verify email request received:\", req.query.token);  // 토큰 확인\r\n\r\n//       const token = req.query.token;\r\n//       if (!token) {\r\n//           console.log(\"No token provided\");\r\n//           return res.status(400).json({ error: '토큰이 제공되지 않았습니다.' });\r\n//       }\r\n\r\n//       const decoded = jwt.verify(token, process.env.JWT_SECRET);\r\n//       console.log(\"Decoded token:\", decoded);\r\n\r\n//       const user = await User.findOne({ email: decoded.email });\r\n//       if (!user) {\r\n//           console.log(\"Invalid user\");\r\n//           return res.status(400).json({ error: '유효하지 않은 사용자입니다.' });\r\n//       }\r\n\r\n//       user.isVerified = true;\r\n//       await user.save();\r\n//       console.log(\"Email verification successful\");\r\n\r\n//       res.status(200).json({ message: '이메일 인증이 성공적으로 완료되었습니다.' });\r\n//   } catch (error) {\r\n//       console.error(\"Email verification error:\", error);\r\n//       res.status(500).json({ error: '서버 오류' });\r\n//   }\r\n// };\r\n\r\nexports.verifyEmail = async (req, res) => {\r\n  try {\r\n      console.log(\"Verify email request received:\", req.query.token);  // 여기서 로그를 추가\r\n\r\n      const token = req.query.token;\r\n      if (!token) {\r\n          console.log(\"No token provided\");\r\n          return res.status(400).json({ error: '토큰이 제공되지 않았습니다.' });\r\n      }\r\n\r\n      const decoded = jwt.verify(token, process.env.JWT_SECRET);\r\n      console.log(\"Decoded token:\", decoded);\r\n\r\n      const user = await User.findOne({ email: decoded.email });\r\n      if (!user) {\r\n          console.log(\"Invalid user\");\r\n          return res.status(400).json({ error: '유효하지 않은 사용자입니다.' });\r\n      }\r\n\r\n      user.isVerified = true;\r\n      await user.save();\r\n      console.log(\"Email verification successful\");\r\n\r\n      res.status(200).json({ message: '이메일 인증이 성공적으로 완료되었습니다.' });\r\n  } catch (error) {\r\n      console.error(\"Email verification error:\", error);\r\n      res.status(500).json({ error: '서버 오류' });\r\n  }\r\n};\r\n\r\n\r\nexports.login = async (req, res) => {\r\n  try {\r\n    const { email, password } = req.body;\r\n    console.log(\"Received login request for:\", email);\r\n    const user = await User.findOne({ email });\r\n    if (!user) return res.status(400).json({ error: '사용자를 찾을 수 없습니다' });\r\n    \r\n    const validPassword = await bcrypt.compare(password, user.password);\r\n    if (!validPassword) return res.status(400).json({ error: '비밀번호가 올바르지 않습니다' });\r\n\r\n    // Ensure that JWT_SECRET is correctly set\r\n    if (!process.env.JWT_SECRET) {\r\n      throw new Error('JWT_SECRET is not set');\r\n    }\r\n\r\n    // Include university in the token payload\r\n    const token = jwt.sign(\r\n      { userId: user._id, university: user.university },  // university 추가\r\n      process.env.JWT_SECRET,\r\n      { expiresIn: '1h' }\r\n    );\r\n\r\n    console.log(\"Login successful, token generated with university\");\r\n    res.json({ token });\r\n  } catch (error) {\r\n    console.error(\"Server error during login:\", error);\r\n    res.status(500).json({ error: '서버 오류' });\r\n  }\r\n};\r\n\r\n\r\nexports.authenticateToken = (req, res, next) => {\r\n  const authHeader = req.headers['authorization'];\r\n  const token = authHeader && authHeader.split(' ')[1];\r\n\r\n  if (!token) return res.status(401).json({ error: '토큰이 제공되지 않았습니다.' });\r\n\r\n  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {\r\n    if (err) return res.status(403).json({ error: '유효하지 않은 토큰입니다.' });\r\n    req.user = user;\r\n    console.log('Decoded user from token:', req.user); // 로그 추가\r\n    next();\r\n  });\r\n};\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}